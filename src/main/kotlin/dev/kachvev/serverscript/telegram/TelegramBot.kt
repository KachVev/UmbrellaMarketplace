package dev.kachvev.serverscript.telegram

import com.github.kotlintelegrambot.bot
import com.github.kotlintelegrambot.dispatch
import com.github.kotlintelegrambot.dispatcher.*
import com.github.kotlintelegrambot.dispatcher.handlers.TextHandlerEnvironment
import com.github.kotlintelegrambot.entities.ChatId
import com.github.kotlintelegrambot.entities.InlineKeyboardMarkup
import com.github.kotlintelegrambot.entities.TelegramFile
import com.github.kotlintelegrambot.entities.keyboard.InlineKeyboardButton
import com.github.kotlintelegrambot.logging.LogLevel
import com.mongodb.MongoTimeoutException
import dev.kachvev.serverscript.ext.downloadFileContent
import dev.kachvev.serverscript.ext.reply
import dev.kachvev.serverscript.ext.toProfileText
import dev.kachvev.serverscript.model.LuaScript
import dev.kachvev.serverscript.repository.LuaScriptRepository
import dev.kachvev.serverscript.service.AuthService
import dev.kachvev.serverscript.service.TokenService
import dev.kachvev.serverscript.telegram.enum.Buttons
import dev.kachvev.serverscript.telegram.menu.startMenu
import dev.kachvev.serverscript.wrapper.TelegramAwaiter
import jakarta.annotation.PostConstruct
import org.springframework.data.mongodb.core.MongoTemplate
import org.springframework.stereotype.Component

@Component
class TelegramBot(
    val luaRepository: LuaScriptRepository,
    val authService: AuthService,
    val tokenService: TokenService,
    val mongoTemplate: MongoTemplate
) {
    val awaiter = TelegramAwaiter()
    val pendingScripts = mutableMapOf<String, LuaScript>()
    val reviewChannelId = ChatId.fromId(-4708596381)

    val bot = bot {
        token = "7738587832:AAHe-DK6ptfFxI5gn46f-5s7SOCA57mIuVo"
        logLevel = LogLevel.Error

        dispatch {
            command("start") {
                val isUserLinked = authService.findUserByTelegramId(message.chat.id.toString()) != null
                startMenu(isUserLinked)
            }
            command("getchatid") {
                val chatId = message.chat.id
                bot.sendMessage(
                    chatId = ChatId.fromId(chatId),
                    text = "üÜî ID —ç—Ç–æ–≥–æ —á–∞—Ç–∞: `$chatId`",
                    parseMode = com.github.kotlintelegrambot.entities.ParseMode.MARKDOWN
                )
            }
            command("admin") {
                val chatId = message.chat.id

                if (!isAdmin(chatId)) {
                    bot.sendMessage(ChatId.fromId(chatId), "‚ùå –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –∞–¥–º–∏–Ω-–º–µ–Ω—é.")
                    return@command
                }

                val markup = InlineKeyboardMarkup.create(
                    listOf(
                        listOf(
                            InlineKeyboardButton.CallbackData("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –≤—Ö–æ–¥–æ–≤", Buttons.AdminMenu.STATS),
                        ),
                        listOf(
                            InlineKeyboardButton.CallbackData("üóë –£–¥–∞–ª–∏—Ç—å —Å–∫—Ä–∏–ø—Ç", Buttons.AdminMenu.DELETE_SCRIPT),
                        )
                    )
                )

                bot.sendMessage(
                    ChatId.fromId(chatId),
                    text = "üõ† *–ê–¥–º–∏–Ω-–º–µ–Ω—é*",
                    parseMode = com.github.kotlintelegrambot.entities.ParseMode.MARKDOWN,
                    replyMarkup = markup
                )
            }
            callbackQuery(Buttons.StartMenu.LINK_ACCOUNT) {
                val chatId = callbackQuery.message?.chat?.id ?: return@callbackQuery
                bot.sendMessage(ChatId.fromId(chatId), "üì• –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–æ–∫–µ–Ω –¥–ª—è –ø—Ä–∏–≤—è–∑–∫–∏.")
                awaiter.awaitText(chatId, ::handleToken)
            }
            callbackQuery(Buttons.StartMenu.PROFILE) {
                val chatId = callbackQuery.message?.chat?.id ?: return@callbackQuery
                val user = authService.findUserByTelegramId(chatId.toString())

                val messageText = user?.toProfileText() ?: "‚ùå –í–∞—à –∞–∫–∫–∞—É–Ω—Ç –Ω–µ –ø—Ä–∏–≤—è–∑–∞–Ω."
                val replyMarkup = user?.let {
                    InlineKeyboardMarkup.create(
                        listOf(
                            listOf(
                                InlineKeyboardButton.CallbackData(
                                    "üì§ –û—Ç–≤—è–∑–∞—Ç—å Telegram",
                                    Buttons.StartMenu.UNLINK_ACCOUNT
                                )
                            )
                        )
                    )
                }

                bot.sendMessage(
                    chatId = ChatId.fromId(chatId),
                    text = messageText,
                    parseMode = com.github.kotlintelegrambot.entities.ParseMode.MARKDOWN,
                    replyMarkup = replyMarkup
                )
            }
            callbackQuery(Buttons.StartMenu.UNLINK_ACCOUNT) {
                val chatId = callbackQuery.message?.chat?.id ?: return@callbackQuery
                val userId = authService.findUserByTelegramId(chatId.toString())?.uniqueId ?: return@callbackQuery
                tokenService.unlinkTelegram(userId)
                bot.sendMessage(ChatId.fromId(chatId), "‚ùå –í–∞—à –∞–∫–∫–∞—É–Ω—Ç —É—Å–ø–µ—à–Ω–æ –æ—Ç–≤—è–∑–∞–Ω!")
            }
            callbackQuery(Buttons.StartMenu.MARKETPLACE) {
                val chatId = callbackQuery.message?.chat?.id ?: return@callbackQuery

                if (authService.findUserByTelegramId(chatId.toString()) == null) {
                    bot.answerCallbackQuery(callbackQuery.id, text = "‚ùå –í–∞—à –∞–∫–∫–∞—É–Ω—Ç –Ω–µ –ø—Ä–∏–≤—è–∑–∞–Ω.", showAlert = true)
                    return@callbackQuery
                }

                sendMarketplacePage(chatId, 0)
            }
            callbackQuery(Buttons.Marketplace.UPLOAD) {
                val chatId = callbackQuery.message?.chat?.id ?: return@callbackQuery
                if (authService.findUserByTelegramId(chatId.toString()) == null) {
                    bot.sendMessage(ChatId.fromId(chatId), "‚ùå –í–∞—à –∞–∫–∫–∞—É–Ω—Ç –Ω–µ –ø—Ä–∏–≤—è–∑–∞–Ω.")
                    return@callbackQuery
                }

                bot.sendMessage(ChatId.fromId(chatId), "üì• –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ Lua-—Å–∫—Ä–∏–ø—Ç –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏.")

                awaiter.awaitDocument(chatId) { env ->
                    val media = env.media
                    val message = env.message

                    val fileContent = downloadFileContent(media.fileId) ?: return@awaitDocument
                    val telegramId = message.chat.id.toString()
                    val user = authService.findUserByTelegramId(telegramId)

                    val script = LuaScript(
                        name = media.fileName ?: "unknown.lua",
                        content = fileContent,
                        author = user?.nickname ?: "unknown"
                    )

                    bot.sendMessage(
                        ChatId.fromId(message.chat.id),
                        "‚úÖ –°–∫—Ä–∏–ø—Ç `${media.fileName}` —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º!"
                    )

                    bot.sendDocument(
                        chatId = reviewChannelId,
                        document = TelegramFile.ByFileId(media.fileId),
                        caption = "üìÑ –ù–æ–≤—ã–π —Å–∫—Ä–∏–ø—Ç –æ—Ç ${script.author}: `${script.name}`",
                        replyMarkup = InlineKeyboardMarkup.create(
                            listOf(
                                listOf(
                                    InlineKeyboardButton.CallbackData("‚úÖ –ü—Ä–∏–Ω—è—Ç—å", "approve:${script.name}"),
                                    InlineKeyboardButton.CallbackData("‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å", "reject:${script.name}")
                                )
                            )
                        )
                    )

                    pendingScripts[script.name] = script
                }
            }
            callbackQuery(Buttons.Marketplace.PAGE) {
                val chatId = callbackQuery.message?.chat?.id ?: return@callbackQuery
                val messageId = callbackQuery.message?.messageId ?: return@callbackQuery

                val parts = callbackQuery.data.split(":")
                val pageIndex = parts.getOrNull(1)?.toIntOrNull() ?: 0

                if (authService.findUserByTelegramId(chatId.toString()) == null) {
                    bot.answerCallbackQuery(callbackQuery.id, text = "‚ùå –í–∞—à –∞–∫–∫–∞—É–Ω—Ç –Ω–µ –ø—Ä–∏–≤—è–∑–∞–Ω.", showAlert = true)
                    return@callbackQuery
                }

                sendMarketplacePage(chatId, pageIndex, messageId)
            }
            callbackQuery(Buttons.Marketplace.ADD_SCRIPT) {
                val chatId = callbackQuery.message?.chat?.id ?: return@callbackQuery
                val messageId = callbackQuery.message?.messageId ?: return@callbackQuery

                val parts = callbackQuery.data.split(":")
                val scriptName = parts.getOrNull(1) ?: return@callbackQuery

                val user = authService.findUserByTelegramId(chatId.toString()) ?: return@callbackQuery

                if (user.accessibleScripts.contains(scriptName)) {
                    user.accessibleScripts.remove(scriptName)
                    bot.answerCallbackQuery(callbackQuery.id, text = "‚ùå –°–∫—Ä–∏–ø—Ç —É–¥–∞–ª—ë–Ω –∏–∑ —Å–ø–∏—Å–∫–∞.", showAlert = false)
                } else {
                    user.accessibleScripts.add(scriptName)
                    bot.answerCallbackQuery(callbackQuery.id, text = "‚úÖ –°–∫—Ä–∏–ø—Ç –¥–æ–±–∞–≤–ª–µ–Ω –≤ —Å–ø–∏—Å–æ–∫.", showAlert = false)
                }

                authService.updateUser(user)

                val allScripts = luaRepository.findAll()
                val pageSize = 5

                val index = allScripts.indexOfFirst { it.name == scriptName }
                val currentPage = if (index != -1) index / pageSize else 0

                val newScriptsCount = allScripts.size
                val newTotalPages = (newScriptsCount + pageSize - 1) / pageSize
                val safePage = if (currentPage >= newTotalPages) (newTotalPages - 1).coerceAtLeast(0) else currentPage

                sendMarketplacePage(chatId, safePage, messageId)
            }
            callbackQuery(Buttons.AdminMenu.STATS) {
                val chatId = callbackQuery.message?.chat?.id ?: return@callbackQuery

                if (!isAdmin(chatId)) {
                    bot.answerCallbackQuery(callbackQuery.id, text = "‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.", showAlert = true)
                    return@callbackQuery
                }

                val users = authService.findUsersLoggedInToday()
                if (users.isEmpty()) {
                    bot.sendMessage(ChatId.fromId(chatId), "üì≠ –°–µ–≥–æ–¥–Ω—è –µ—â—ë –Ω–∏–∫—Ç–æ –Ω–µ –∑–∞—Ö–æ–¥–∏–ª.")
                    return@callbackQuery
                }

                val text = buildString {
                    append("üìä *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ —Å–µ–≥–æ–¥–Ω—è:*\n\n")
                    users.forEach { user ->
                        val minutesAgo = java.time.Duration.between(user.lastLogin, dev.kachvev.serverscript.ext.nowMoscow()).toMinutes()
                        val niceMinutesAgo = if (minutesAgo < 1) "–¢–æ–ª—å–∫–æ —á—Ç–æ" else "$minutesAgo –º–∏–Ω—É—Ç –Ω–∞–∑–∞–¥"
                        val usernameLink = user.telegramId?.let { "[${user.nickname}](tg://user?id=$it)" } ?: user.nickname
                        append("‚Ä¢ $usernameLink ‚Äî $niceMinutesAgo\n")
                    }
                }

                bot.sendMessage(
                    ChatId.fromId(chatId),
                    text = text,
                    parseMode = com.github.kotlintelegrambot.entities.ParseMode.MARKDOWN
                )
            }
            callbackQuery(Buttons.AdminMenu.DELETE_SCRIPT) {
                val chatId = callbackQuery.message?.chat?.id ?: return@callbackQuery

                if (!isAdmin(chatId)) {
                    bot.answerCallbackQuery(callbackQuery.id, text = "‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.", showAlert = true)
                    return@callbackQuery
                }

                bot.sendMessage(ChatId.fromId(chatId), "‚úèÔ∏è –û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Å–∫—Ä–∏–ø—Ç–∞, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å.")

                awaiter.awaitText(chatId) { env ->
                    val scriptName = env.message.text?.trim()

                    if (scriptName.isNullOrBlank()) {
                        env.reply("‚ùå –ü—É—Å—Ç–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ.")
                        return@awaitText
                    }

                    val script = luaRepository.findByName(scriptName)
                    if (script == null) {
                        env.reply("‚ùå –°–∫—Ä–∏–ø—Ç `$scriptName` –Ω–µ –Ω–∞–π–¥–µ–Ω.")
                        return@awaitText
                    }

                    luaRepository.delete(script)
                    env.reply("‚úÖ –°–∫—Ä–∏–ø—Ç `$scriptName` —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª—ë–Ω.")
                }
            }


            callbackQuery {
                val data = callbackQuery.data
                if (data.startsWith("approve:") || data.startsWith("reject:")) {
                    val chatId = callbackQuery.message?.chat?.id ?: return@callbackQuery
                    val parts = data.split(":")
                    val action = parts[0]
                    val scriptName = parts.getOrNull(1) ?: return@callbackQuery

                    val script = pendingScripts[scriptName]
                    if (script == null) {
                        bot.answerCallbackQuery(callbackQuery.id, text = "‚ùå –°–∫—Ä–∏–ø—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –æ–∂–∏–¥–∞–Ω–∏–∏.", showAlert = true)
                        return@callbackQuery
                    }

                    when (action) {
                        "approve" -> {
                            luaRepository.save(script)
                            bot.sendMessage(
                                chatId = ChatId.fromId(chatId),
                                text = "‚úÖ –°–∫—Ä–∏–ø—Ç `${script.name}` –ø—Ä–∏–Ω—è—Ç –∏ –¥–æ–±–∞–≤–ª–µ–Ω –≤ –≤–∞—à —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–∫—Ä–∏–ø—Ç–æ–≤."
                            )
                        }
                        "reject" -> {
                            bot.sendMessage(
                                chatId = ChatId.fromId(chatId),
                                text = "‚ùå –°–∫—Ä–∏–ø—Ç `${script.name}` –æ—Ç–∫–ª–æ–Ω—ë–Ω. –í—ã –º–æ–∂–µ—Ç–µ –∑–∞–≥—Ä—É–∑–∏—Ç—å –Ω–æ–≤—ã–π."
                            )

                        }
                    }

                    pendingScripts.remove(scriptName)

                    bot.answerCallbackQuery(callbackQuery.id, text = "–ì–æ—Ç–æ–≤–æ!")
                }
            }

            text {
                if (awaiter.handleIfAwaitingText(this)) return@text
            }
            document {
                if (awaiter.handleIfAwaitingDocument(this)) return@document
            }
            photos {
                if (awaiter.handleIfAwaitingPhoto(this)) return@photos
            }
            video {
                if (awaiter.handleIfAwaitingVideo(this)) return@video
            }
            audio {
                if (awaiter.handleIfAwaitingAudio(this)) return@audio
            }
            sticker {
                if (awaiter.handleIfAwaitingSticker(this)) return@sticker
            }
            voice {
                if (awaiter.handleIfAwaitingVoice(this)) return@voice
            }
        }
    }

    @PostConstruct
    fun start() {
        Thread {
            while (true) {
                try {
                    mongoTemplate.executeCommand("{ ping: 1 }")
                    println("‚úÖ MongoDB –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ. –ó–∞–ø—É—Å–∫–∞–µ–º Telegram-–±–æ—Ç–∞.")
                    bot.startPolling()
                    break
                } catch (ex: MongoTimeoutException) {
                    println("‚ùå [MongoTimeoutException] –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ MongoDB: ${ex.localizedMessage}")
                } catch (ex: Exception) {
                    println("‚ùå [Exception] –ù–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ MongoDB: ${ex.localizedMessage}")
                }

                println("‚è≥ –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ —á–µ—Ä–µ–∑ 5 —Å–µ–∫—É–Ω–¥...")
                Thread.sleep(5000)
            }
        }.start()
    }

    fun isAdmin(chatId: Long): Boolean {
        return chatId in listOf(7582738324L, 873934194L)
    }

    fun handleToken(env: TextHandlerEnvironment) {
        val token = env.message.text?.trim()
        val chatId = env.message.chat.id.toString()

        when {
            token.isNullOrBlank() -> env.reply("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ç–æ–∫–µ–Ω.")
            authService.findUserByTelegramId(chatId) != null -> env.reply("‚ùå –í–∞—à Telegram —É–∂–µ –ø—Ä–∏–≤—è–∑–∞–Ω –∫ –∞–∫–∫–∞—É–Ω—Ç—É.")
            authService.linkTelegramByToken(token, env.message.chat.id) -> env.reply("‚úÖ Telegram —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–≤—è–∑–∞–Ω –∫ –≤–∞—à–µ–º—É –∞–∫–∫–∞—É–Ω—Ç—É!")
            else -> env.reply("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –∏–ª–∏ –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã–π —Ç–æ–∫–µ–Ω.")
        }
    }

    fun sendMarketplacePage(chatId: Long, pageIndex: Int, messageId: Long? = null) {
        val user = authService.findUserByTelegramId(chatId.toString()) ?: return
        val scripts = luaRepository.findAll()
        val pageSize = 5
        val totalPages = (scripts.size + pageSize - 1) / pageSize

        val pageScripts = scripts.drop(pageIndex * pageSize).take(pageSize)

        val text = buildString {
            if (pageScripts.isEmpty()) {
                append("‚ùå –ù–∞ —ç—Ç–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ –Ω–µ—Ç —Å–∫—Ä–∏–ø—Ç–æ–≤.")
            } else {
                append("üõí –°—Ç—Ä–∞–Ω–∏—Ü–∞ ${pageIndex + 1} –∏–∑ $totalPages\n")
                append("–î–æ—Å—Ç—É–ø–Ω—ã–µ —Å–∫—Ä–∏–ø—Ç—ã:")
            }
        }

        val buttons = mutableListOf<List<InlineKeyboardButton>>()

        pageScripts.forEach { script ->
            val isSelected = script.id != null && user.accessibleScripts.contains(script.name)
            val buttonText = (if (isSelected) "‚úÖ " else "") + script.name

            buttons.add(
                listOf(
                    InlineKeyboardButton.CallbackData(
                        text = buttonText,
                        callbackData = "${Buttons.Marketplace.ADD_SCRIPT}:${script.name}"
                    )
                )
            )
        }

        val navButtons = mutableListOf<InlineKeyboardButton>()
        if (pageIndex > 0) {
            navButtons.add(InlineKeyboardButton.CallbackData("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", "${Buttons.Marketplace.PAGE}:${pageIndex - 1}"))
        }
        if ((pageIndex + 1) * pageSize < scripts.size) {
            navButtons.add(InlineKeyboardButton.CallbackData("‚û°Ô∏è –í–ø–µ—Ä—ë–¥", "${Buttons.Marketplace.PAGE}:${pageIndex + 1}"))
        }
        if (navButtons.isNotEmpty()) {
            buttons.add(navButtons)
        }

        buttons.add(
            listOf(
                InlineKeyboardButton.CallbackData("üìù –ó–∞–≥—Ä—É–∑–∏—Ç—å —Å–∫—Ä–∏–ø—Ç", Buttons.Marketplace.UPLOAD)
            )
        )

        val markup = InlineKeyboardMarkup.create(buttons)

        if (messageId == null) {
            bot.sendMessage(
                ChatId.fromId(chatId),
                text = text,
                replyMarkup = markup
            )
        } else {
            bot.editMessageText(
                chatId = ChatId.fromId(chatId),
                messageId = messageId,
                text = text,
                replyMarkup = markup
            )
        }
    }
}
